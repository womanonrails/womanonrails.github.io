<!DOCTYPE html><html lang="pl"><head><meta charset='utf-8'><title>Programowanie funkcyjne w Ruby</title><meta name='description' content='Krótkie wprowadzenie do bloków, lambd, domknięć i obiektów typu Proc.'><meta name='viewport' content='width=device-width, initial-scale=1.0'><meta name="generator" content="Jekyll v4.0.1" /><meta property="og:title" content="Programowanie funkcyjne w Ruby" /><meta name="author" content="womanonrails" /><meta property="og:locale" content="pl" /><meta name="description" content="Krótkie wprowadzenie do bloków, lambd, domknięć i obiektów typu Proc." /><meta property="og:description" content="Krótkie wprowadzenie do bloków, lambd, domknięć i obiektów typu Proc." /><link rel="canonical" href="https://womanonrails.com/pl/functional-programming-ruby" /><meta property="og:url" content="https://womanonrails.com/pl/functional-programming-ruby" /><meta property="og:site_name" content="Woman on Rails" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-07-03T00:00:00-04:00" /> <script type="application/ld+json"> {"description":"Krótkie wprowadzenie do bloków, lambd, domknięć i obiektów typu Proc.","url":"https://womanonrails.com/pl/functional-programming-ruby","@type":"BlogPosting","headline":"Programowanie funkcyjne w Ruby","dateModified":"2019-07-03T00:00:00-04:00","datePublished":"2019-07-03T00:00:00-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://womanonrails.com/pl/functional-programming-ruby"},"author":{"@type":"Person","name":"womanonrails"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://womanonrails.com/pl/womanonrails-square.svg"},"name":"womanonrails"},"@context":"https://schema.org"}</script><meta name='twitter:card' content='summary'><meta name='twitter:creator' content='@womanonrails'><meta name='twitter:description' content='Krótkie wprowadzenie do bloków, lambd, domknięć i obiektów typu Proc.'><meta name='twitter:image' content='https://womanonrails.com/images/womanonrails-square.svg'><meta name='twitter:title' content='Programowanie funkcyjne w Ruby'><meta property='og:description' content='Krótkie wprowadzenie do bloków, lambd, domknięć i obiektów typu Proc.'><meta property='og:image' content='https://womanonrails.com/images/womanonrails-1000x1000.jpg'><meta property='og:title' content='Programowanie funkcyjne w Ruby'><meta property='og:type' content='website'><link href='https://womanonrails.com/favicon.ico' rel='shortcut icon' type='image/x-icon' /><link href='https://womanonrails.com/favicon.png' rel='shortcut icon' type='image/png' /><link href='/pl/feed.xml' rel='alternate' title='Woman on Rails Feed' type='application/atom+xml' /><link async href='/assets/css/bootstrap.css' media='all' rel='stylesheet' /><link href='/assets/css/style.css' media='all' rel='stylesheet' /><link href='/css/main.css' media='all' rel='stylesheet' /><link href='/assets/css/applause-button.css' rel='stylesheet' /> <script defer src='/assets/js/applause-button.js'></script><div class="search-wrapper"><div class="search-form"> <input type="text" class="search-field" placeholder="Search..."> <span class='js-remove-sign'> <span class='svg--cancel'><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 375 375"><path d="M187.5 2.5a185 185 0 0 0-185 185 185 185 0 0 0 185 185 185 185 0 0 0 185-185 185 185 0 0 0-185-185zm-85.906 78.875a20.232 20.232 0 0 1 14.518 6.132l71.388 71.388 71.388-71.388a20.232 20.232 0 0 1 13.909-6.121 20.232 20.232 0 0 1 14.702 34.73l-71.39 71.388 71.39 71.39a20.232 20.232 0 1 1-28.61 28.61L187.5 216.115l-71.388 71.389a20.232 20.232 0 1 1-28.611-28.61l71.39-71.39-71.39-71.388a20.232 20.232 0 0 1 14.093-34.74z"/></svg></span> </span><ul class="search-results post-list"></ul></div></div></head><body class="post-template" itemscope itemtype="https://schema.org/WebPage"><div id="fade"></div><a id="slide" class="animated fade"></a><aside id="sidebar"><nav id="navigation"><h2>MENU</h2><hr><ul><li> <a href="https://womanonrails.com/">Strona główna</a></li><li> <a href="https://womanonrails.com/pl/workshops">Kursy programowania</a></li><li> <a href="https://womanonrails.com/pl/categories">Kategorie</a></li><li> <a href="https://womanonrails.com/pl/tags">Tagi</a></li><li> <a href="https://womanonrails.com/pl/about">O mnie</a></li><li> <a href="https://bemore.womanonrails.com/">Be more</a></li><li> <a href="/pl/feed.xml" title='Atom/RSS feed'> <span class='svg--rss'><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>RSS icon</title><path d="M19.199 24C19.199 13.467 10.533 4.8 0 4.8V0c13.165 0 24 10.835 24 24h-4.801zM3.291 17.415c1.814 0 3.293 1.479 3.293 3.295 0 1.813-1.485 3.29-3.301 3.29C1.47 24 0 22.526 0 20.71s1.475-3.294 3.291-3.295zM15.909 24h-4.665c0-6.169-5.075-11.245-11.244-11.245V8.09c8.727 0 15.909 7.184 15.909 15.91z"/></svg></span> Feed </a></li></ul></nav></aside><header class='blog-background overlay align-center align-middle animated from-bottom' id='masthead' itemscope itemtype='https://schema.org/Organization'> <button class='menu-button animated fade dosearch' title='Wyszukaj'> <span class='svg--search'><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 13"> <g stroke-width="1.5" fill="none"><path d="M11.29 11.71l-4-4"/><circle cx="5" cy="5" r="4"/> </g> </svg></span> </button> <a href="/functional-programming-ruby" class='language animated fade'> en </a><div class='inner'><div class='container'> <a class='brand' href='/pl/' itemprop='url' role='banner'> <img itemprop='logo' src="https://womanonrails.com/images/womanonrails-square.svg" alt="Woman on Rails Logo" width='120' /><h1 class='blog-title light' itemprop='name'> Woman on Rails</h1></a><h2 class='blog-description light bordered bordered-top' itemprop='description'> Premature optimization is the root of all evil.</h2></div></div><div class="decor-wrapper"> <svg id="header-decor" class="decor bottom" xmlns="https://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100" preserveAspectRatio="none"><path class="large left" d="M0 0 L50 50 L0 100" fill="rgba(255,255,255, .1)"></path><path class="large right" d="M100 0 L50 50 L100 100" fill="rgba(255,255,255, .1)"></path><path class="medium left" d="M0 100 L50 50 L0 33.3" fill="rgba(255,255,255, .3)"></path><path class="medium right" d="M100 100 L50 50 L100 33.3" fill="rgba(255,255,255, .3)"></path><path class="small left" d="M0 100 L50 50 L0 66.6" fill="rgba(255,255,255, .5)"></path><path class="small right" d="M100 100 L50 50 L100 66.6" fill="rgba(255,255,255, .5)"></path><path d="M0 99.9 L50 49.9 L100 99.9 L0 99.9" fill="rgba(255,255,255, 1)"></path><path d="M48 52 L50 49 L52 52 L48 52" fill="rgba(255,255,255, 1)"></path> </svg></div></header><div class='content' id='main' itemprop='mainContentOfPage' itemscope itemtype='https://schema.org/WebPageElement' role='main'><div class='container'><div class='row'><div class='applause hidden-xs hidden-sm'> <applause-button color='#c33' multiclap='true' style='width: 58px; height: 58px;' url='https://womanonrails.com/pl/functional-programming-ruby' /></div><article class='post col-md-8 col-md-offset-2 hentry' itemprop='blogPost' itemscope itemtype='https://schema.org/BlogPosting'><header class='post-header entry-header'><h1 class='post-title text-center hyper lighter bordered-bottom entry-title' itemprop='headline'> Programowanie funkcyjne w Ruby</h1><div class='cursive'>Krótkie wprowadzenie do bloków, lambd, domknięć i obiektów typu Proc.</div><div class='post-info text-center small'> <span class='post-tags'> <a data-toggle='tooltip' href="/pl/categories/#programowanie" title="Other posts from the Programowanie category" rel="tag">Programowanie</a> </span> | <span class='post-tags reading-time'> <span class='time'>14</span> min. </span></div></header><div class='post-body bordered-bottom' itemprop='description'><p>Ruby jest językiem obiektowym. Nie znaczy to jednak, że nie możemy przy pomocy Rubiego programować bardziej funkcyjnie. Gdy przyjrzymy się historii języka Ruby zauważymy, że u jego podstaw leży wiele różnych technologi. Twórca Rubiego, Yukihiro Matsumoto, inspirował się takimi językami jak: Perl, Smalltalk, Eiffel, Ada, Basic czy Lisp. Dzięki tym wszystkich inspiracjom w języku Ruby możemy znaleźć nie tylko koncepcje programowania obiektowego, ale również odrobinę programowania funkcyjnego.</p><p>Zanim jednak przejdziemy do szczegółów, wytłumaczę podstawowe pojęcia. Czym jest <strong>programowanie funkcyjne</strong>? Jest to <strong>paradygmat programowania</strong>. Znaczy to tyle, że jest to sposób klasyfikowania języka na podstawie jego cech. W takim razie jakimi cechami charakteryzuje się programowanie funkcyjne?</p><ul><li>Czyste funkcje (Pure functions) - Funkcja zawsze zwraca ten sam wynik dla tych samych argumentów i nie powoduje dodatkowego, obserwowalnego efektu ubocznego. Tak właśnie zachowują się funkcje w matematyce.</li><li>Niezmienność (Immutability) - Po utworzeniu stanu (wpisaniu wartości do zmiennej) nie możemy go już zmienić. Zamiast zmieniać stan, tworzymy nowy.</li><li>Przejrzystość referencyjna (Referential transparency) - jest to połączenie dwóch poprzednich pojęć.</li><li>Memoization - Jest to efekt uboczny przejrzystości referencyjnej. Pozwala przyspieszyć obliczenia za pomocą zapamiętania już wcześniej wywołanych kalkulacji, które przy kolejnym wywołaniu dadzą ten sam wynik.</li><li>Idempotentność (Idempotence) - Niezależnie ile razy wywołamy daną funkcję na sobie samej, da nam ona ten sam wynik. Jest to też konsekwencja przejrzystości referencyjnej.</li><li>Funkcje wyższego rzędu (Higher-order functions) - Funkcja, która przyjmuje inną funkcję jako argument lub zwraca funkcję jako wynik.</li><li>Rozwijanie funkcji (Currying) - Jest to operacja, która przekształca funkcję wieloargumentową w funkcję przyjmującą jeden argument, ale zwracającą na wyjście nową funkcję. Można powiedzieć, że to rodzaj generatora funkcji.</li><li>Rekurencja (Recursion) - Wywołanie funkcji przez samą siebie. W programowaniu odbywa się to bardzo często tak długo, aż zostanie osiągnięty wcześniej zdefiniowany warunek zatrzymania.</li><li>Wartościowanie leniwe (Lazy evaluation) - Podejście pozwalające na obliczanie zadanych kalkulacji (często argumentów wejściowych funkcji) dopiero wtedy, gdy są one potrzebne, a nie na początku po ich zadeklarowaniu.</li></ul><p>Teraz gdy już wiemy trochę o samej koncepcji programowania funkcyjnego możemy przejść do funkcyjnego podejścia do programowania w języku Ruby.</p><h2 id="bloki-w-ruby">Bloki w Ruby</h2><p><strong>Blok jest funkcją bez nazwy w języku Ruby.</strong> Funkcją anonimową, o której powiem więcej w części dotyczącej lambdy. Taki blok możemy podać, jako ostatni argument do innej funkcji i może być on <strong>tylko jeden</strong>. W języku Ruby bloki są też związane z funkcjami wyższego rzędu. Często wykorzystywanym blokiem kodu jest <code class="highlighter-rouge">each</code>:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">].</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span>
  <span class="nb">p</span> <span class="n">item</span>
<span class="k">end</span>

<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">4</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
</code></pre></div></div><p>Stwórzmy teraz nasz własny blok:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_own_block</span>
  <span class="nb">p</span> <span class="s1">'before'</span>
  <span class="k">yield</span> <span class="k">if</span> <span class="nb">block_given?</span>
  <span class="nb">p</span> <span class="s1">'after'</span>
<span class="k">end</span>

<span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_own_block</span>
<span class="s2">"before"</span>
<span class="s2">"after"</span>
 <span class="o">=&gt;</span> <span class="s2">"after"</span>
</code></pre></div></div><p>Jak widzisz <code class="highlighter-rouge">my_own_block</code> zachowuje się jak normalna funkcja, ponieważ nią właśnie jest. Magia zaczyna się dopiero wtedy, gdy zaczniemy używać <code class="highlighter-rouge">yield</code>. Ale co to tak właściwie jest ten <code class="highlighter-rouge">yield</code>? Jest to wywołanie bloku kodu, naszej funkcji niemającej nazwy, którą możemy podać jako argument metody <code class="highlighter-rouge">my_own_block</code>. Zobaczmy, jak można to zrobić:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_own_block</span> <span class="p">{</span> <span class="nb">p</span> <span class="mi">5</span> <span class="p">}</span>
<span class="s2">"before"</span>
<span class="mi">5</span>
<span class="s2">"after"</span>
 <span class="o">=&gt;</span> <span class="s2">"after
</span></code></pre></div></div><p>By wywołać nasz blok kodu jako argument funkcji, potrzebujemy użyć nawiasów klamrowych <code class="highlighter-rouge">{}</code> lub klauzuli <code class="highlighter-rouge">do end</code>. Nie możemy użyć naturalnych dla nas w takim przypadku nawiasów okrągłych <code class="highlighter-rouge">()</code>. Gdybyśmy tak zrobiły, dostałybyśmy błąd:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_own_block</span><span class="p">(</span><span class="nb">p</span> <span class="mi">5</span><span class="p">)</span>
<span class="mi">5</span>
<span class="no">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
        <span class="mi">6</span><span class="p">:</span> <span class="n">from</span> <span class="sr">/home/</span><span class="n">agnieszka</span><span class="o">/</span><span class="p">.</span><span class="nf">rvm</span><span class="o">/</span><span class="n">rubies</span><span class="o">/</span><span class="n">ruby</span><span class="o">-</span><span class="mf">2.6</span><span class="o">.</span><span class="mi">1</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">irb</span><span class="p">:</span><span class="mi">23</span><span class="ss">:in</span> <span class="sb">`&lt;main&gt;'
        5: from /home/agnieszka/.rvm/rubies/ruby-2.6.1/bin/irb:23:in `</span><span class="nb">load</span><span class="s1">'
        4: from /home/agnieszka/.rvm/rubies/ruby-2.6.1/lib/ruby/gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in `&lt;top (required)&gt;'</span>
        <span class="mi">3</span><span class="p">:</span> <span class="n">from</span> <span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">13</span>
        <span class="mi">2</span><span class="p">:</span> <span class="n">from</span> <span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">13</span><span class="ss">:in</span> <span class="sb">`rescue in irb_binding'
        1: from (irb):4:in `</span><span class="n">my_own_block</span><span class="err">'</span>
<span class="no">ArgumentError</span> <span class="p">(</span><span class="n">wrong</span> <span class="n">number</span> <span class="n">of</span> <span class="n">arguments</span> <span class="p">(</span><span class="n">given</span> <span class="mi">1</span><span class="p">,</span> <span class="n">expected</span> <span class="mi">0</span><span class="p">))</span>
</code></pre></div></div><p>Na samym początku widzimy liczbę <code class="highlighter-rouge">5</code>, ponieważ Ruby zaczyna od wywołania (obliczenia) wszystkich argumentów funkcji. Przy okazji możemy powiedzieć, że jest to <strong>zachłanne wartościowanie</strong> (strict evaluation), czyli coś odwrotnego do wartościowania leniwego, o którym była mowa na początku artykułu. Dalej widzimy wyjątek <code class="highlighter-rouge">wrong number of arguments (given 1, expected 0)</code> mówiący nam, że nasza metoda spodziewa się zerowej ilości argumentów, a otrzymała jeden. Oznacza to, że argumenty typu blokowego są traktowane przez język Ruby w inny sposób niż pozostałe argumenty. Nie możemy ich użyć, jak normalnych argumentów. Przynajmniej na razie. W dalszej części artykułu pokażę jak to zrobić.</p><p>W tym przykładzie nie powiedziałam Ci jeszcze o jednej rzeczy. Co to jest <code class="highlighter-rouge">block_given?</code>? Jest to metoda, która pomaga nam sprawdzić, czy blok kodu został podany jako argument do metody <code class="highlighter-rouge">my_own_block</code>. Gdybyśmy tego nie sprawdziły w przypadku braku podania bloku do naszej metody, otrzymałybyśmy błąd. Zobaczmy, jak to wygląda na przykładzie:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_own_block</span>
  <span class="nb">p</span> <span class="s1">'before'</span>
  <span class="k">yield</span>
  <span class="nb">p</span> <span class="s1">'after'</span>
<span class="k">end</span>

<span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_own_block</span>
<span class="s2">"before"</span>
<span class="no">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
        <span class="mi">5</span><span class="p">:</span> <span class="n">from</span> <span class="sr">/home/</span><span class="n">agnieszka</span><span class="o">/</span><span class="p">.</span><span class="nf">rvm</span><span class="o">/</span><span class="n">rubies</span><span class="o">/</span><span class="n">ruby</span><span class="o">-</span><span class="mf">2.6</span><span class="o">.</span><span class="mi">1</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">irb</span><span class="p">:</span><span class="mi">23</span><span class="ss">:in</span> <span class="sb">`&lt;main&gt;'
        4: from /home/agnieszka/.rvm/rubies/ruby-2.6.1/bin/irb:23:in `</span><span class="nb">load</span><span class="s1">'
        3: from /home/agnieszka/.rvm/rubies/ruby-2.6.1/lib/ruby/gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in `&lt;top (required)&gt;'</span>
        <span class="mi">2</span><span class="p">:</span> <span class="n">from</span> <span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">19</span>
        <span class="mi">1</span><span class="p">:</span> <span class="n">from</span> <span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">16</span><span class="ss">:in</span> <span class="sb">`my_own_block'
LocalJumpError (no block given (yield))
</span></code></pre></div></div><h2 id="obiekt-proc">Obiekt Proc</h2><p><strong>Proc</strong> jest jedną z klas dostępnych w języku Ruby (w standardowej bibliotece tego języka). <code class="highlighter-rouge">Proc</code> jest obiektem, który enkapsuluje (hermetyzuje) blok kodu i pozwala wpisać go do zmiennej. Taka zmienna może zostać przekazana jako argument do metody i tam wywołana jak normalny blok kodu. To właśnie obiekt <code class="highlighter-rouge">Proc</code> jest jedną z podstawowych koncepcji programowania funkcyjnego w języku Ruby.</p><p>We wcześniejszych przykładach widziałaś już jeden sposób deklarowania metody z argumentem typu blok. Oto inny sposób deklaracji:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_block</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="nb">p</span> <span class="s1">'before'</span>
  <span class="nb">p</span> <span class="n">block</span><span class="p">.</span><span class="nf">class</span>
  <span class="n">block</span><span class="p">.</span><span class="nf">call</span>
  <span class="nb">p</span> <span class="s1">'after'</span>
<span class="k">end</span>
</code></pre></div></div><p>Możemy wywołać naszą metodę w ten sam sposób jak poprzednio:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_block</span> <span class="p">{</span> <span class="nb">p</span> <span class="mi">4</span> <span class="p">}</span>
<span class="s2">"before"</span>
<span class="no">Proc</span>
<span class="mi">4</span>
<span class="s2">"after"</span>
 <span class="o">=&gt;</span> <span class="s2">"after"</span>
</code></pre></div></div><p>Podczas wywołania naszej metody widzimy, że obiekt znajdujący się pod zmienną <code class="highlighter-rouge">block</code> jest instancją klasy <code class="highlighter-rouge">Proc</code>. Tym razem by wywołać nasz blok kodu używamy <code class="highlighter-rouge">block.call</code> zamiast metody <code class="highlighter-rouge">yield</code>. Jednak obiekt typu <code class="highlighter-rouge">Proc</code> jest jeszcze ciekawszy niż taki zwykły blok. Możemy wiele takich obiektów przekazać jako argumenty funkcji:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run_proc</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span>
  <span class="n">first</span><span class="p">.</span><span class="nf">call</span>
  <span class="n">last</span><span class="p">.</span><span class="nf">call</span>
<span class="k">end</span>
<span class="n">proc1</span> <span class="o">=</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="nb">p</span> <span class="s1">'first'</span> <span class="p">}</span>
<span class="n">proc2</span> <span class="o">=</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="nb">p</span> <span class="s1">'last'</span> <span class="p">}</span>

<span class="n">irb</span><span class="o">&gt;</span> <span class="n">run_proc</span> <span class="n">proc1</span><span class="p">,</span> <span class="n">proc2</span>
<span class="s2">"first"</span>
<span class="s2">"last"</span>
 <span class="o">=&gt;</span> <span class="s2">"last"</span>
</code></pre></div></div><p>Obiekt typu <code class="highlighter-rouge">Proc</code> możemy wywołać również poza metodą i to na wiele różnych sposobów:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_proc</span> <span class="o">=</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span>
  <span class="nb">p</span> <span class="s2">"Text: </span><span class="si">#{</span><span class="n">item</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>

<span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_proc</span><span class="p">.</span><span class="nf">call</span> <span class="mi">10</span>
<span class="s2">"Text: 10"</span>
 <span class="o">=&gt;</span> <span class="s2">"Text: 10"</span>

<span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_proc</span><span class="o">.</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
<span class="s2">"Text: 20"</span>
 <span class="o">=&gt;</span> <span class="s2">"Text: 20"</span>

<span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_proc</span><span class="p">[</span><span class="mi">30</span><span class="p">]</span>
<span class="s2">"Text: 30"</span>
 <span class="o">=&gt;</span> <span class="s2">"Text: 30"</span>

<span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_proc</span> <span class="o">===</span> <span class="mi">40</span>
<span class="s2">"Text: 40"</span>
 <span class="o">=&gt;</span> <span class="s2">"Text: 40"</span>
</code></pre></div></div><p>To pozwala nam na wykorzystanie obiektu <code class="highlighter-rouge">Proc</code> również w klauzuli <code class="highlighter-rouge">case</code>:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">proc1</span> <span class="o">=</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">number</span><span class="o">|</span> <span class="n">number</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">}</span>
<span class="n">proc2</span> <span class="o">=</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">number</span><span class="o">|</span> <span class="n">number</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">}</span>

<span class="k">case</span> <span class="mi">3</span>
<span class="k">when</span> <span class="n">proc1</span> <span class="k">then</span> <span class="nb">p</span> <span class="s1">'proc1'</span>
<span class="k">when</span> <span class="n">proc2</span> <span class="k">then</span> <span class="nb">p</span> <span class="s1">'proc2'</span>
<span class="k">else</span>
  <span class="nb">p</span> <span class="s1">'not a proc'</span>
<span class="k">end</span>
<span class="s2">"proc1"</span>
 <span class="o">=&gt;</span> <span class="s2">"proc1"</span>
</code></pre></div></div><p>Ponieważ <code class="highlighter-rouge">case</code> podczas sprawdzania warunków używa operatora porównania (equality operator) <code class="highlighter-rouge">===</code>, a obiekt <code class="highlighter-rouge">Proc</code> implementuje tą metodę, możemy używać obiektu <code class="highlighter-rouge">Proc</code> wewnątrz <code class="highlighter-rouge">case</code>. Przy okazji z tego samego powodu w <code class="highlighter-rouge">case</code> możemy używać również obiektów typu <code class="highlighter-rouge">Range</code>:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">irb</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">4</span><span class="o">..</span><span class="mi">7</span><span class="p">)</span> <span class="o">===</span> <span class="mi">5</span>
 <span class="o">=&gt;</span> <span class="kp">true</span>

<span class="n">irb</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">4</span><span class="o">..</span><span class="mi">7</span><span class="p">)</span> <span class="o">===</span> <span class="mi">8</span>
 <span class="o">=&gt;</span> <span class="kp">false</span>
</code></pre></div></div><p>A teraz pokażę Ci jeszcze jeden sposób na zadeklarowanie metody z wykorzystaniem obiektu <code class="highlighter-rouge">Proc</code>:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run_proc</span>
  <span class="nb">p</span> <span class="s1">'before'</span>
  <span class="n">my_proc</span> <span class="o">=</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span>
  <span class="n">my_proc</span><span class="p">.</span><span class="nf">call</span>
  <span class="nb">p</span> <span class="s1">'after'</span>
<span class="k">end</span>

<span class="n">irb</span><span class="o">&gt;</span> <span class="n">run_proc</span> <span class="p">{</span> <span class="nb">p</span> <span class="mi">6</span> <span class="p">}</span>
<span class="s2">"before"</span>
<span class="mi">6</span>
<span class="s2">"after"</span>
 <span class="o">=&gt;</span> <span class="s2">"after"</span>
</code></pre></div></div><p>Kiedy przyjrzysz się tej implementacji bliżej, może się ona wydać dziwna. Nie deklarujemy argumentu dla naszej metody, więc jak <code class="highlighter-rouge">Proc.new</code> wie co robić? Normalnie gdy użyjemy <code class="highlighter-rouge">Proc.new</code> bez deklaracji bloku kodu dostaniemy wyjątek <code class="highlighter-rouge">tried to create Proc object without a block</code>. W tym przypadku <code class="highlighter-rouge">Proc.new</code> nie ma swojej deklaracji bloku, więc będzie szukał jego deklaracji w bieżącym zakresie (scope). Kiedy więc uruchamiamy metodę <code class="highlighter-rouge">run_proc</code> wraz z blokiem kodu, wszystko działa jak należy.</p><h2 id="lambdy">Lambdy</h2><p><strong>Lambda</strong> to funkcja anonimowa. Jest to definicja funkcji, która nie ma swojej nazwy. Nie ma swojego identyfikatora. Ale taką funkcję możesz wpisać do zmiennej, a później wywołać ją w dowolnym miejscu. Funkcje anonimowe są często wykorzystywane i przekazywane jako argumenty do innych funkcji, funkcji wyższego rzędu. W języku Ruby lambda jest bardzo podobna do obiektu <code class="highlighter-rouge">Proc</code>, choć istnieją pomiędzy nimi małe różnice. Oto one:</p><h4 id="kontrola-ilości-argumentów">Kontrola ilości argumentów</h4><p>Zadeklarujemy sobie lambdę i obiekt typu <code class="highlighter-rouge">Proc</code>. Przy okazji w dalszej części artykułu będę zamiennie stosować dwie formy deklaracji obiektu <code class="highlighter-rouge">Proc</code>: <code class="highlighter-rouge">Proc.new</code> i <code class="highlighter-rouge">proc</code>.</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_proc</span> <span class="o">=</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span> <span class="nb">p</span> <span class="s2">"==</span><span class="si">#{</span><span class="n">item</span><span class="si">}</span><span class="s2">=="</span> <span class="p">}</span>
<span class="n">my_lambda</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span> <span class="nb">p</span> <span class="s2">"==</span><span class="si">#{</span><span class="n">item</span><span class="si">}</span><span class="s2">=="</span> <span class="p">}</span>
</code></pre></div></div><p>Te dwa obiekty mają tą samą klasę:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_proc</span><span class="p">.</span><span class="nf">class</span>
 <span class="o">=&gt;</span> <span class="no">Proc</span>

<span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_lambda</span><span class="p">.</span><span class="nf">class</span>
 <span class="o">=&gt;</span> <span class="no">Proc</span>
</code></pre></div></div><p>Mają też tą samą ilość argumentów (tą samą arność):</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_proc</span><span class="p">.</span><span class="nf">arity</span>
 <span class="o">=&gt;</span> <span class="mi">1</span>

<span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_lambda</span><span class="p">.</span><span class="nf">arity</span>
 <span class="o">=&gt;</span> <span class="mi">1</span>
</code></pre></div></div><p>Istnieje jednak pomiędzy nimi różnica, gdy wywołamy je bez argumentów lub ze złą ilością argumentów. <code class="highlighter-rouge">Proc</code> wykona się natomiast lambda zwróci wyjątek:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_proc</span><span class="p">.</span><span class="nf">call</span>
<span class="s2">"===="</span>
 <span class="o">=&gt;</span> <span class="s2">"===="</span>

<span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_lambda</span><span class="p">.</span><span class="nf">call</span>
<span class="no">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
        <span class="mi">5</span><span class="p">:</span> <span class="n">from</span> <span class="sr">/home/</span><span class="n">agnieszka</span><span class="o">/</span><span class="p">.</span><span class="nf">rvm</span><span class="o">/</span><span class="n">rubies</span><span class="o">/</span><span class="n">ruby</span><span class="o">-</span><span class="mf">2.6</span><span class="o">.</span><span class="mi">1</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">irb</span><span class="p">:</span><span class="mi">23</span><span class="ss">:in</span> <span class="sb">`&lt;main&gt;'
        4: from /home/agnieszka/.rvm/rubies/ruby-2.6.1/bin/irb:23:in `</span><span class="nb">load</span><span class="s1">'
        3: from /home/agnieszka/.rvm/rubies/ruby-2.6.1/lib/ruby/gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in `&lt;top (required)&gt;'</span>
        <span class="mi">2</span><span class="p">:</span> <span class="n">from</span> <span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">77</span>
        <span class="mi">1</span><span class="p">:</span> <span class="n">from</span> <span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">62</span><span class="ss">:in</span> <span class="sb">`block in irb_binding'
ArgumentError (wrong number of arguments (given 0, expected 1))
</span></code></pre></div></div><p>Jak już pokazałam wcześniej nie da się rozróżnić obiektu <code class="highlighter-rouge">Proc</code> i lambdy na podstawie klasy. Da się je rozróżnić używając metody <code class="highlighter-rouge">lambda?</code>.</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_proc</span><span class="p">.</span><span class="nf">lambda?</span>
 <span class="o">=&gt;</span> <span class="kp">false</span>

<span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_lambda</span><span class="p">.</span><span class="nf">lambda?</span>
 <span class="o">=&gt;</span> <span class="kp">true</span>
</code></pre></div></div><p>Chciałabym dodać tu jeszcze jedną rzecz. Jeżeli zadeklarujemy w lambdzie listę argumentów w postaci tablicy, ilość argumentów będzie widoczna jako <code class="highlighter-rouge">-1</code>.</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">irb</span><span class="o">&gt;</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|*</span><span class="n">items</span><span class="o">|</span> <span class="p">}.</span><span class="nf">arity</span>
 <span class="o">=&gt;</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div><p>Na koniec pokażę Ci jeszcze jeden sposób na zadeklarowanie lambdy przy pomocy operatora strzałkowego (arrow operator) <code class="highlighter-rouge">-&gt;</code>.</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_lambda</span> <span class="o">=</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">{</span> <span class="nb">p</span> <span class="s2">"==</span><span class="si">#{</span><span class="n">item</span><span class="si">}</span><span class="s2">=="</span> <span class="p">}</span>

<span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_lambda</span><span class="p">.</span><span class="nf">lambda?</span>
 <span class="o">=&gt;</span> <span class="kp">true</span>
</code></pre></div></div><h4 id="używanie-z-return">Używanie z return</h4><p>Na początek zadeklarujemy metodę, która będzie wywoływać obiekt typu <code class="highlighter-rouge">Proc</code> lub lambdę.</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="nb">proc</span><span class="p">)</span>
  <span class="nb">p</span> <span class="s1">'before'</span>
  <span class="nb">proc</span><span class="p">.</span><span class="nf">call</span>
  <span class="nb">p</span> <span class="s1">'after'</span>
<span class="k">end</span>
</code></pre></div></div><p>Uruchommy naszą metodę <code class="highlighter-rouge">run</code> z lambdą:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">irb</span><span class="o">&gt;</span> <span class="n">run</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="nb">p</span> <span class="s1">'in'</span><span class="p">;</span> <span class="k">return</span> <span class="p">}</span>
<span class="s2">"before"</span>
<span class="s2">"in"</span>
<span class="s2">"after"</span>
 <span class="o">=&gt;</span> <span class="s2">"after"</span>
</code></pre></div></div><p>Wszystko wygląda w porządku. To teraz przejdźmy do <code class="highlighter-rouge">Proc</code>:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">irb</span><span class="o">&gt;</span> <span class="n">run</span> <span class="nb">proc</span> <span class="p">{</span> <span class="nb">p</span> <span class="s1">'in'</span><span class="p">;</span> <span class="k">return</span> <span class="p">}</span>
<span class="s2">"before"</span>
<span class="s2">"in"</span>
<span class="no">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
        <span class="mi">6</span><span class="p">:</span> <span class="n">from</span> <span class="sr">/home/</span><span class="n">agnieszka</span><span class="o">/</span><span class="p">.</span><span class="nf">rvm</span><span class="o">/</span><span class="n">rubies</span><span class="o">/</span><span class="n">ruby</span><span class="o">-</span><span class="mf">2.6</span><span class="o">.</span><span class="mi">1</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">irb</span><span class="p">:</span><span class="mi">23</span><span class="ss">:in</span> <span class="sb">`&lt;main&gt;'
        5: from /home/agnieszka/.rvm/rubies/ruby-2.6.1/bin/irb:23:in `</span><span class="nb">load</span><span class="s1">'
        4: from /home/agnieszka/.rvm/rubies/ruby-2.6.1/lib/ruby/gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in `&lt;top (required)&gt;'</span>
        <span class="mi">3</span><span class="p">:</span> <span class="n">from</span> <span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">91</span>
        <span class="mi">2</span><span class="p">:</span> <span class="n">from</span> <span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">87</span><span class="ss">:in</span> <span class="sb">`run'
        1: from (irb):91:in `</span><span class="n">block</span> <span class="k">in</span> <span class="n">irb_binding</span><span class="err">'</span>
<span class="no">LocalJumpError</span> <span class="p">(</span><span class="n">unexpected</span> <span class="k">return</span><span class="p">)</span>
</code></pre></div></div><p>Widzimy błąd. Nasze wywołanie zaczyna się od <code class="highlighter-rouge">"before"</code>, później obiekt <code class="highlighter-rouge">Proc</code> wypisuje <code class="highlighter-rouge">"in"</code> i zaraz po tym dostajemy wyjątek. Dzieje się tak dlatego, że <code class="highlighter-rouge">Proc</code> nie zwraca bieżącego kontekstu ale <strong>zwraca kontekst w którym został zdefiniowany</strong>. To znaczy, że w tym konkretnym przypadku próbuje wyjść z głównego kontekstu naszej interaktywnej konsoli irb. Ponieważ <code class="highlighter-rouge">Proc</code> nie ma uprawnień do wyjścia z głównego kontekstu my widzimy błąd. Spróbujmy w takim razie zmienić kontekst:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">change_context</span>
  <span class="n">run</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="nb">p</span> <span class="s1">'in'</span><span class="p">;</span> <span class="k">return</span> <span class="p">}</span>
  <span class="n">run</span> <span class="nb">proc</span> <span class="p">{</span> <span class="nb">p</span> <span class="s1">'in'</span><span class="p">;</span> <span class="k">return</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div><p>Uruchommy teraz metodę <code class="highlighter-rouge">change_context</code>:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">irb</span><span class="o">&gt;</span> <span class="n">change_context</span>
<span class="s2">"before"</span>
<span class="s2">"in"</span>
<span class="s2">"after"</span>
<span class="s2">"before"</span>
<span class="s2">"in"</span>
 <span class="o">=&gt;</span> <span class="kp">nil</span>
</code></pre></div></div><p>Na początku zostaje wywołana lambda. A na ekranie zostaje wypisane: <code class="highlighter-rouge">"before"</code>, <code class="highlighter-rouge">"in"</code> i <code class="highlighter-rouge">"after"</code>. Później zostaje wywołany obiekt <code class="highlighter-rouge">Proc</code>. I widzimy <code class="highlighter-rouge">"before"</code>, <code class="highlighter-rouge">"in"</code>. Po tym nasza metoda się kończy. Nasz <code class="highlighter-rouge">Proc</code> wyszedł z kontekstu w którym został utworzony, czyli wyszedł z metody <code class="highlighter-rouge">change_context</code> a drugi <code class="highlighter-rouge">"after"</code> nigdy nie został wyświetlony.</p><h2 id="domknięcia-closures">Domknięcia (Closures)</h2><p><strong>Domknięcie</strong> to technika tworzenia funkcji na podstawie innej funkcji korzystając z jej kontekstu (środowiska stworzenia). Ten <strong>kontekst ma wpływ na funkcję podczas jej deklaracji</strong>. Domknięcie jest to jeden ze sposobów na generowanie nowych funkcji i jest on związany z tematem funkcji wyższego rzędu. By lepiej zobrazować czym jest domknięcie przejdźmy do przykładu:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">multiple</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
  <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">n</span><span class="o">|</span> <span class="n">n</span> <span class="o">*</span> <span class="n">m</span> <span class="p">}</span>
<span class="k">end</span>

<span class="n">double</span> <span class="o">=</span> <span class="n">multiple</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">triple</span> <span class="o">=</span> <span class="n">multiple</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Execute</span>
<span class="n">irb</span><span class="o">&gt;</span> <span class="n">double</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
 <span class="o">=&gt;</span> <span class="mi">10</span>
<span class="n">irb</span><span class="o">&gt;</span> <span class="n">triple</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
 <span class="o">=&gt;</span> <span class="mi">15</span>
</code></pre></div></div><p>Deklarujemy funkcję <code class="highlighter-rouge">multiple</code>, która posiada jeden argument. W środku tej funkcji używamy lambdy, która również przyjmuje jeden argument, ale dodatkowo używa zmiennej <code class="highlighter-rouge">m</code> zadeklarowanych w zakresie funkcji <code class="highlighter-rouge">multiple</code>. Teraz możemy generować funkcje na podstawie metody <code class="highlighter-rouge">multiple</code>. Gdy podstawiamy wartość <code class="highlighter-rouge">2</code> za <code class="highlighter-rouge">m</code> otrzymujemy funkcję anonimową (lambdę) <code class="highlighter-rouge">double</code>. Wewnętrznie ta lambda wraz z kontekstem, w którym została stworzona wygląda tak: <code class="highlighter-rouge">lambda { |n| n * 2 }</code>. Teraz gdy będziemy chciały użyć funkcji <code class="highlighter-rouge">double</code> z argumentem <code class="highlighter-rouge">5</code>, wartość ta zostanie podstawiana do zmiennej <code class="highlighter-rouge">n</code>. Otrzymamy <code class="highlighter-rouge">5 * 2</code> czyli <code class="highlighter-rouge">10</code>.</p><p>Jest jeszcze jedna rzecz, którą warto zapamiętać. W języku Ruby podczas tworzenia domknięcia zapamiętywana jest referencja do zmiennej, a nie jej wartość. To dość istotne, bo w innych językach programowania spotyka się raczej sytuację, gdy to wartość jest zapamiętywana. Ta cecha domknięcia w języku Ruby powoduje, że jesteśmy w stanie zmienić kontekst po jego deklaracji. Nie możemy natomiast stworzyć (zadeklarować) kontekstu po deklaracji domknięcia. Zobaczmy to na przykładach poniżej, zaczynając od sytuacji, gdy kontekst nie był zadeklarowany w chwili tworzenia domknięcia:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_proc</span> <span class="o">=</span> <span class="nb">proc</span> <span class="p">{</span> <span class="nb">p</span> <span class="n">first_name</span> <span class="p">}</span>

<span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_proc</span><span class="p">.</span><span class="nf">call</span>
<span class="no">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
        <span class="mi">5</span><span class="p">:</span> <span class="n">from</span> <span class="sr">/home/</span><span class="n">agnieszka</span><span class="o">/</span><span class="p">.</span><span class="nf">rvm</span><span class="o">/</span><span class="n">rubies</span><span class="o">/</span><span class="n">ruby</span><span class="o">-</span><span class="mf">2.6</span><span class="o">.</span><span class="mi">1</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">irb</span><span class="p">:</span><span class="mi">23</span><span class="ss">:in</span> <span class="sb">`&lt;main&gt;'
        4: from /home/agnieszka/.rvm/rubies/ruby-2.6.1/bin/irb:23:in `</span><span class="nb">load</span><span class="s1">'
        3: from /home/agnieszka/.rvm/rubies/ruby-2.6.1/lib/ruby/gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in `&lt;top (required)&gt;'</span>
        <span class="mi">2</span><span class="p">:</span> <span class="n">from</span> <span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">107</span>
        <span class="mi">1</span><span class="p">:</span> <span class="n">from</span> <span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">105</span><span class="ss">:in</span> <span class="sb">`block in irb_binding'
NameError (undefined local variable or method `</span><span class="n">first_name</span><span class="err">'</span> <span class="k">for</span> <span class="n">main</span><span class="ss">:Object</span><span class="p">)</span>
</code></pre></div></div><p>Dostajemy błąd. Nie pomoże nam nawet próba do deklarowania brakującego kontekstu:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">first_name</span> <span class="o">=</span> <span class="s2">"Agnieszka"</span>
 <span class="o">=&gt;</span> <span class="s2">"Agnieszka"</span>

<span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_proc</span><span class="p">.</span><span class="nf">call</span>
<span class="no">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
        <span class="mi">5</span><span class="p">:</span> <span class="n">from</span> <span class="sr">/home/</span><span class="n">agnieszka</span><span class="o">/</span><span class="p">.</span><span class="nf">rvm</span><span class="o">/</span><span class="n">rubies</span><span class="o">/</span><span class="n">ruby</span><span class="o">-</span><span class="mf">2.6</span><span class="o">.</span><span class="mi">1</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">irb</span><span class="p">:</span><span class="mi">23</span><span class="ss">:in</span> <span class="sb">`&lt;main&gt;'
        4: from /home/agnieszka/.rvm/rubies/ruby-2.6.1/bin/irb:23:in `</span><span class="nb">load</span><span class="s1">'
        3: from /home/agnieszka/.rvm/rubies/ruby-2.6.1/lib/ruby/gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in `&lt;top (required)&gt;'</span>
        <span class="mi">2</span><span class="p">:</span> <span class="n">from</span> <span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">109</span>
        <span class="mi">1</span><span class="p">:</span> <span class="n">from</span> <span class="p">(</span><span class="n">irb</span><span class="p">):</span><span class="mi">105</span><span class="ss">:in</span> <span class="sb">`block in irb_binding'
NameError (undefined local variable or method `</span><span class="n">first_name</span><span class="err">'</span> <span class="k">for</span> <span class="n">main</span><span class="ss">:Object</span><span class="p">)</span>
</code></pre></div></div><p>Nie jest możliwe dodanie kontekstu po deklaracji naszego domknięcia. Natomiast jak zobaczysz w następnym przykładzie możemy zmienić już istniejący kontekst:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">name</span> <span class="o">=</span> <span class="s1">'Agnieszka'</span>
<span class="n">my_proc</span> <span class="o">=</span> <span class="nb">proc</span> <span class="p">{</span> <span class="nb">p</span> <span class="nb">name</span> <span class="p">}</span>

<span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_proc</span><span class="p">.</span><span class="nf">call</span>
<span class="s2">"Agnieszka"</span>
 <span class="o">=&gt;</span> <span class="s2">"Agnieszka"</span>

<span class="nb">name</span> <span class="o">=</span> <span class="s1">'Ula'</span>
<span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_proc</span><span class="p">.</span><span class="nf">call</span>
<span class="s2">"Ula"</span>
 <span class="o">=&gt;</span> <span class="s2">"Ula"</span>
</code></pre></div></div><h4 id="metoda-jako-lambda">Metoda jako “lambda”</h4><p>Możemy zdefiniować metodę, a później użyć jej jako coś w rodzaj funkcji anonimowej:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_method</span>
  <span class="nb">p</span> <span class="s1">'Hello word'</span>
<span class="k">end</span>

<span class="n">my_proc</span> <span class="o">=</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:my_method</span><span class="p">)</span>

<span class="n">irb</span><span class="o">&gt;</span> <span class="n">my_proc</span><span class="p">.</span><span class="nf">call</span>
<span class="s2">"Hello word"</span>
 <span class="o">=&gt;</span> <span class="s2">"Hello word"</span>
</code></pre></div></div><h4 id="typy-domknięć-w-języku-ruby">Typy domknięć w języku Ruby</h4><p>Mamy kilka typów domknięć w języku Ruby:</p><ul><li>block + <code class="highlighter-rouge">yield</code></li><li>block + <code class="highlighter-rouge">&amp;b</code></li><li><code class="highlighter-rouge">Proc.new</code></li><li><code class="highlighter-rouge">proc</code></li><li><code class="highlighter-rouge">lambda</code></li><li><code class="highlighter-rouge">method</code></li></ul><h4 id="gdzie-używamy-domknięć">Gdzie używamy domknięć?</h4><p>Czysty Ruby:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span> <span class="nb">p</span> <span class="n">item</span> <span class="p">}</span>

<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nf">each_cons</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">|</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="p">}</span>

<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span> <span class="n">item</span><span class="p">.</span><span class="nf">next</span> <span class="p">}</span>

<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nf">inject</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">sum</span><span class="p">,</span> <span class="n">item</span><span class="o">|</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">item</span> <span class="p">}</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nf">inject</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="o">+</span><span class="p">)</span>
</code></pre></div></div><p>W Ruby on Rails:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">respond_to</span> <span class="k">do</span> <span class="o">|</span><span class="nb">format</span><span class="o">|</span>
  <span class="nb">format</span><span class="p">.</span><span class="nf">html</span> <span class="c1"># index.html.erb</span>
  <span class="nb">format</span><span class="p">.</span><span class="nf">xml</span>  <span class="p">{</span> <span class="n">render</span> <span class="ss">:xml</span> <span class="o">=&gt;</span> <span class="vi">@items</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div><h2 id="ciekawostka---lisp-w-języku-ruby">Ciekawostka - Lisp w języku Ruby</h2><p>By stworzyć listy podobne do list jakie występują w języku Lisp, będziemy potrzebować leniwego wartościowania i rekurencji. Ale najpierw zobaczmy jak wyglądają listy w języku Lisp.</p><div class="language-common-lisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">write</span> <span class="o">'</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
 <span class="nv">=&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>

<span class="p">(</span><span class="nb">write</span> <span class="p">(</span><span class="nb">car</span> <span class="o">'</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)))</span>
 <span class="nv">=&gt;</span> <span class="mi">1</span>

<span class="p">(</span><span class="nb">write</span> <span class="p">(</span><span class="nb">cdr</span> <span class="o">'</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)))</span>
 <span class="nv">=&gt;</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</code></pre></div></div><p>Jeżeli czytałaś mój artykuł o <a href="/pl/elixir-pattern-matching" title="Elixir - Dopasowanie do wzorca">podstawach języka Elixir</a> możesz porównać <code class="highlighter-rouge">car</code> i <code class="highlighter-rouge">cdr</code> do <code class="highlighter-rouge">head</code> i <code class="highlighter-rouge">tail</code> w Elixirze. <code class="highlighter-rouge">car</code> zawsze zwróci pierwszy element listy, natomiast <code class="highlighter-rouge">cdr</code> zwróci listę bez pierwszego elementu. Zacznijmy od przygotowania tablicy w języku Ruby, która będzie się zachowywać jak lista w języku Lisp.</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">car</span><span class="p">,</span> <span class="n">cdr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">2</span><span class="p">,[</span><span class="mi">3</span><span class="p">]]]</span>

<span class="n">irb</span><span class="o">&gt;</span> <span class="n">car</span>
 <span class="o">=&gt;</span> <span class="mi">1</span>

<span class="n">irb</span><span class="o">&gt;</span> <span class="n">cdr</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
</code></pre></div></div><p>Teraz przygotujemy własny enumerator, który będzie mógł iterować po takich listach:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LispyEnumerable</span>
  <span class="kp">include</span> <span class="no">Enumerable</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="vi">@tree</span> <span class="o">=</span> <span class="n">tree</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">each</span>
    <span class="k">while</span> <span class="vi">@tree</span>
      <span class="n">car</span><span class="p">,</span> <span class="n">cdr</span> <span class="o">=</span> <span class="vi">@tree</span>
      <span class="k">yield</span> <span class="n">car</span>
      <span class="vi">@tree</span> <span class="o">=</span> <span class="n">cdr</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div><p>To pozwoli nam na zrobienie pewnych operacji na <code class="highlighter-rouge">car</code> początkowym elemencie listy i nadpisze zmienną <code class="highlighter-rouge">@tree</code> nową krótszą o jeden element tablicą <code class="highlighter-rouge">cdr</code>. Nasz kod możemy wywołać w następujący sposób:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,[</span><span class="mi">2</span><span class="p">,[</span><span class="mi">3</span><span class="p">]]]</span>
<span class="n">irb</span><span class="o">&gt;</span> <span class="no">LispyEnumerable</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">list</span><span class="p">).</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span> <span class="nb">p</span> <span class="n">item</span> <span class="p">}</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
 <span class="o">=&gt;</span> <span class="kp">nil</span>
</code></pre></div></div><p>Na tą chwilę nasza lista nie jest leniwie wartościowana. Aby to zmienić użyjemy lambdy:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LazyLispyEnumerable</span>
  <span class="kp">include</span> <span class="no">Enumerable</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="vi">@tree</span> <span class="o">=</span> <span class="n">tree</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">each</span>
    <span class="k">while</span> <span class="vi">@tree</span>
      <span class="n">car</span><span class="p">,</span> <span class="n">cdr</span> <span class="o">=</span> <span class="vi">@tree</span><span class="p">.</span><span class="nf">call</span>
      <span class="k">yield</span> <span class="n">car</span>
      <span class="vi">@tree</span> <span class="o">=</span> <span class="n">cdr</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div><p>Zmieniłyśmy tylko jedną linię. Za każdym razem gdy będziemy wchodzić do kolejnego kroku naszej pętli, będziemy wykonywać kolejny element naszej tablicy za pomocą <code class="highlighter-rouge">@tree.call</code>. Żeby jednak użyć tego nowego enumeratora musimy zmienić również naszą listę.</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">list</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">}</span> <span class="p">]</span> <span class="p">}</span> <span class="p">]</span> <span class="p">}</span>
<span class="n">irb</span><span class="o">&gt;</span> <span class="no">LazyLispyEnumerable</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">list</span><span class="p">).</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span> <span class="nb">p</span> <span class="n">item</span> <span class="p">}</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
 <span class="o">=&gt;</span> <span class="kp">nil</span>
</code></pre></div></div><p>Na tą chwilę nie widać różnicy. By ją zobaczyć zmienimy naszą listę. Jeżeli jest to zachłanne wartościowanie, to przy nowej deklaracji listy powinniśmy dostać wszystkie wypisania od razu na ekranie. Natomiast jeżeli jest to wartościowanie leniwe, będziemy je dostawać krok po kroku podczas wykonywania naszej pętli.</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">list</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="k">do</span>
  <span class="nb">p</span> <span class="s1">'1 is called'</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="nb">lambda</span> <span class="k">do</span>
    <span class="nb">p</span> <span class="s1">'2 is called'</span>
    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="nb">p</span> <span class="s1">'3 is called'</span><span class="p">;</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">}]</span>
  <span class="k">end</span><span class="p">]</span>
<span class="k">end</span>

<span class="n">irb</span><span class="o">&gt;</span> <span class="no">LazyLispyEnumerable</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">list</span><span class="p">).</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span> <span class="nb">p</span> <span class="n">item</span> <span class="p">}</span>
<span class="s2">"1 is called"</span>
<span class="mi">1</span>
<span class="s2">"2 is called"</span>
<span class="mi">2</span>
<span class="s2">"3 is called"</span>
<span class="mi">3</span>
 <span class="o">=&gt;</span> <span class="kp">nil</span>
</code></pre></div></div><p>Jak widać udało się nam zadeklarować leniwe wartościowanie. Przyszedł czas by napisać ciąg Fibonacci’ego przy użyciu naszego leniwego wartościowania:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fibo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="nb">lambda</span> <span class="p">{</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">fibo</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)]</span> <span class="p">}</span>
<span class="k">end</span>

<span class="no">LazyLispyEnumerable</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">fibo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">item</span>
  <span class="k">break</span> <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;</span> <span class="mi">100</span>
<span class="k">end</span>
<span class="mi">1</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">5</span>
<span class="mi">8</span>
<span class="mi">13</span>
<span class="mi">21</span>
<span class="mi">34</span>
<span class="mi">55</span>
<span class="mi">89</span>
<span class="mi">144</span>
 <span class="o">=&gt;</span> <span class="kp">nil</span>
</code></pre></div></div><p>Do kodu dodałam warunek zatrzymania, bez niego Ruby mógłby teoretycznie robić te kalkulacje w nieskończoność. W pewnym sensie nie jest to do końca rekurencja. Możemy powiedzieć, że jest to nieskończona pętla. Jeżeli chciałybyśmy tu użyć prawdziwej rekurencji kod wyglądałby następująco:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">recursive_fibo</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span>
  <span class="n">recursive_fibo</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">recursive_fibo</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">irb</span><span class="o">&gt;</span> <span class="n">recursive_fibo</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>
 <span class="o">=&gt;</span> <span class="mi">144</span>
</code></pre></div></div><p>W tym przypadku gdy usuniemy warunki zatrzymania otrzymamy wyjątek <code class="highlighter-rouge">SystemStackError (stack level too deep)</code>. To rozwiązanie będzie też znacznie wolniejsze niż nasze <em>“leniwe rozwiązanie”</em>.</p><p>Na koniec chciałabym tylko wspomnieć że od wersji Ruby 2.0 możemy używać leniwych enumeratorów (lazy enumerators) za pośrednictwem samego języka:</p><div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">irb</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="no">Float</span><span class="o">::</span><span class="no">INFINITY</span><span class="p">).</span><span class="nf">lazy</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:even?</span><span class="p">).</span><span class="nf">first</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
 <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
</code></pre></div></div><p>Jeżeli chciałabyś dowiedzieć się o nich czegoś więcej, to odsyłam Cię do <a href="https://ruby-doc.org/core/Enumerator/Lazy.html" rel="nofollow" target="_blank">dokumentacji leniwych enumeratorów</a>.</p><p>To wszystko na dzisiaj. Mam nadzieję, że Cię to zainteresowało. Jeżeli masz jakieś pytania, to umieść je w komentarzu na dole. Do zobaczenia!</p><h2 id="bibliografia">Bibliografia:</h2><ul><li><a href="https://www.youtube.com/watch?v=VBC-G6hahWA" rel="nofollow">Wideo o programowaniu funkcyjnym (Proc, Lambda, Closure) w Ruby [EN]</a></li><li><a href="https://www.slideshare.net/tokland/functional-programming-with-ruby-9975242" rel="nofollow" target="_blank">Prezentacja o programowaniu funkcyjnym w Ruby [EN]</a></li><li><a href="https://innig.net/software/ruby/closures-in-ruby" rel="nofollow" target="_blank">Artykuł na temat domknięć w Ruby [EN]</a></li><li><a href="https://ruby-doc.org/" rel="nofollow" target="_blank">Dokumentacja Ruby [EN]</a></li></ul><br><div class='entry-tags text-center'> <span class='svg--tags'><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 230 230"><path d="M95.084 0H.13v95.475L134.658 230l95.212-95.212L95.084 0zM61.138 61.268c-6.988 6.989-18.321 6.989-25.309 0-6.989-6.987-6.99-18.321 0-25.308 6.987-6.99 18.321-6.989 25.309 0 6.989 6.987 6.989 18.321 0 25.308z"/></svg></span> Tagged with <a href="/pl/tags/#Ruby" data-toggle='tooltip' title='Posts tagged with Ruby' rel='tag'>Ruby</a></div></div></article></div><footer class='post-footer entry-meta'><div class='post-share text-center'><p class='light small'> Share this post</p><ul class='social-mini'><li> <a data-toggle='tooltip' href="https://twitter.com/intent/tweet?text=&quot;Programowanie funkcyjne w Ruby&quot;%20https://womanonrails.com/functional-programming-ruby%20via%20&#64;womanonrails" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;" title='Share on Twitter'> <span class='svg--twitter'><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg></span> </a></li><li> <a data-toggle='tooltip' href='https://www.facebook.com/sharer/sharer.php?u=https://womanonrails.com/functional-programming-ruby' onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;" title='Share on Facebook'> <span class='svg--facebook'><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 264 512"><path d="M76.7 512V283H0v-91h76.7v-71.7C76.7 42.4 124.3 0 193.8 0c33.3 0 61.9 2.5 70.2 3.6V85h-48.2c-37.8 0-45.1 18-45.1 44.3V192H256l-11.7 91h-73.6v229"/></svg></span> </a></li></ul></div><div class="post-author text-center"> <img src="https://womanonrails.com/images/womanonrails-square.svg" alt="Agnieszka Małaszkiewicz's photo" itemprop="image" class="post-avatar img-circle img-responsive"/><h4 class="bordered-bottom vcard author" itemprop="author" itemscope itemtype="https://schema.org/Person">By <span itemprop="name" class="fn"><a href="https://womanonrails.com/about" title="About Agnieszka Małaszkiewicz" itemprop="url">Agnieszka Małaszkiewicz</a></span></h4><p>Woman, programmer, mentor, speaker, photographer and dancer with passion.</p></div></footer></div></div><footer id='footer' class='blog-background overlay text-center align-middle animated from-top'><div class='inner'><div class='container'><ul class='social-icons'><li> <a href='https://twitter.com/womanonrails' rel='nofollow noopener noreferrer' target='_blank'> <span class='svg--twitter'><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg></span> </a></li><li> <a href='https://facebook.com/107403177317825' rel='nofollow noopener noreferrer' target='_blank'> <span class='svg--facebook'><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 264 512"><path d="M76.7 512V283H0v-91h76.7v-71.7C76.7 42.4 124.3 0 193.8 0c33.3 0 61.9 2.5 70.2 3.6V85h-48.2c-37.8 0-45.1 18-45.1 44.3V192H256l-11.7 91h-73.6v229"/></svg></span> </a></li><li> <a href='https://stackoverflow.com/users/2885676/womanonrails' rel='nofollow noopener noreferrer' target='_blank'> <span class='svg--stackoverflow'><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><path d="M293.7 300l-181.2-84.5 16.7-36.5 181.3 84.7-16.8 36.3zm48-76L188.2 95.7l-25.5 30.8 153.5 128.3 25.5-30.8zm39.6-31.7L262 32l-32 24 119.3 160.3 32-24zM290.7 311L95 269.7 86.8 309l195.7 41 8.2-39zm31.6 129H42.7V320h-40v160h359.5V320h-40v120zm-39.8-80h-200v39.7h200V360z"/></svg></span> </a></li><li> <a href='https://linkedin.com/in/womanonrails' rel='nofollow noopener noreferrer' target='_blank'> <span class='svg--linkedin'><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M100.3 480H7.4V180.9h92.9V480zM53.8 140.1C24.1 140.1 0 115.5 0 85.8 0 56.1 24.1 32 53.8 32c29.7 0 53.8 24.1 53.8 53.8 0 29.7-24.1 54.3-53.8 54.3zM448 480h-92.7V334.4c0-34.7-.7-79.2-48.3-79.2-48.3 0-55.7 37.7-55.7 76.7V480h-92.8V180.9h89.1v40.8h1.3c12.4-23.5 42.7-48.3 87.9-48.3 94 0 111.3 61.9 111.3 142.3V480z"/></svg></span> </a></li><li> <a href='https://instagram.com/womanonrails_programuje' rel='nofollow noopener noreferrer' target='_blank'> <span class='svg--linkedin'><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"/></svg></span> </a></li><li> <a href='https://github.com/womanonrails' rel='nofollow noopener noreferrer' target='_blank'> <span class='svg--github'><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path d="M165.9 399.378c0 2.052-2.3 3.693-5.2 3.693-3.3.307-5.6-1.334-5.6-3.693 0-2.05 2.3-3.692 5.2-3.692 3-.307 5.6 1.334 5.6 3.692zm-31.1-4.615c-.7 2.051 1.3 4.41 4.3 5.026 2.6 1.025 5.6 0 6.2-2.052.6-2.05-1.3-4.41-4.3-5.333-2.6-.718-5.5.308-6.2 2.36zm44.2-1.743c-2.9.718-4.9 2.666-4.6 5.025.3 2.051 2.9 3.385 5.9 2.667 2.9-.718 4.9-2.667 4.6-4.718-.3-1.949-3-3.282-5.9-2.974zM244.8 0C106.1 0 0 107.998 0 250.253c0 113.741 69.8 211.073 169.5 245.33 12.8 2.358 17.3-5.744 17.3-12.411 0-6.359-.3-41.435-.3-62.973 0 0-70 15.384-84.7-30.564 0 0-11.4-29.846-27.8-37.538 0 0-22.9-16.102 1.6-15.794 0 0 24.9 2.05 38.6 26.46 21.9 39.59 58.6 28.205 72.9 21.436 2.3-16.41 8.8-27.794 16-34.563-55.9-6.36-112.3-14.667-112.3-113.332 0-28.205 7.6-42.358 23.6-60.41-2.6-6.666-11.1-34.153 2.6-69.64 20.9-6.666 69 27.693 69 27.693 20-5.744 41.5-8.718 62.8-8.718 21.3 0 42.8 2.974 62.8 8.718 0 0 48.1-34.461 69-27.692 13.7 35.589 5.2 62.973 2.6 69.64 16 18.153 25.8 32.307 25.8 60.409 0 98.973-58.9 106.87-114.8 113.332 9.2 8.102 17 23.486 17 47.589 0 34.563-.3 77.332-.3 85.742 0 6.666 4.6 14.769 17.3 12.41 100-34.05 167.8-131.383 167.8-245.124C496 107.998 383.5 0 244.8 0zM97.2 353.738c-1.3 1.026-1 3.385.7 5.333 1.6 1.641 3.9 2.36 5.2 1.026 1.3-1.026 1-3.385-.7-5.333-1.6-1.641-3.9-2.36-5.2-1.026zm-10.8-8.307c-.7 1.333.3 2.974 2.3 4 1.6 1.025 3.6.717 4.3-.718.7-1.334-.3-2.975-2.3-4-2-.616-3.6-.308-4.3.718zm32.4 36.512c-1.6 1.333-1 4.41 1.3 6.359 2.3 2.359 5.2 2.666 6.5 1.025 1.3-1.333.7-4.41-1.3-6.359-2.2-2.358-5.2-2.666-6.5-1.025zm-11.4-15.077c-1.6 1.026-1.6 3.692 0 6.051 1.6 2.36 4.3 3.385 5.6 2.36 1.6-1.334 1.6-4 0-6.36-1.4-2.359-4-3.384-5.6-2.05z"/></svg></span> </a></li></ul><div> Agnieszka Małaszkiewicz &copy; 2021 &bull; All rights reserved.</div><ul class='menu-items'><li> <a href="/"> <span class='svg--home'><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M16 256L256 64l96 72v-32h48v72l96 80h-48v192H328V288h-96v160H64V256z"/></svg></span> </a>&bull;</li><li> <a href="/workshops"> Programming courses </a>&bull;</li><li> <a href="/categories"> Categories </a>&bull;</li><li> <a href="/tags"> Tags </a>&bull;</li><li> <a href="/about"> About </a>&bull;</li><li> <a href="/pl/feed.xml" title='Atom/RSS feed'> <span class='svg--rss'><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>RSS icon</title><path d="M19.199 24C19.199 13.467 10.533 4.8 0 4.8V0c13.165 0 24 10.835 24 24h-4.801zM3.291 17.415c1.814 0 3.293 1.479 3.293 3.295 0 1.813-1.485 3.29-3.301 3.29C1.47 24 0 22.526 0 20.71s1.475-3.294 3.291-3.295zM15.909 24h-4.665c0-6.169-5.075-11.245-11.244-11.245V8.09c8.727 0 15.909 7.184 15.909 15.91z"/></svg></span> Feed </a></li></ul></div><div> <a class='btn btn-default' href='https://paypal.me/womanonrails' target='_blank' rel='nofollow noopener' style='border-radius: 10px !important;'> <img alt='PayPal' height='20' src='/images/donations/paypal.svg'> </a> <a href='https://ko-fi.com/womanonrails' target='_blank' rel='nofollow noopener'> <img alt='Ko-fi' height='34' src='/images/donations/ko-fi.svg'> </a></div></div><div class="decor-wrapper"> <svg id="footer-decor" class="decor top" xmlns="https://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 100" preserveAspectRatio="none"><path class="large left" d="M0 0 L50 50 L0 100" fill="rgba(255,255,255, .1)"></path><path class="large right" d="M100 0 L50 50 L100 100" fill="rgba(255,255,255, .1)"></path><path class="medium left" d="M0 0 L50 50 L0 66.6" fill="rgba(255,255,255, .3)"></path><path class="medium right" d="M100 0 L50 50 L100 66.6" fill="rgba(255,255,255, .3)"></path><path class="small left" d="M0 0 L50 50 L0 33.3" fill="rgba(255,255,255, .5)"></path><path class="small right" d="M100 0 L50 50 L100 33.3" fill="rgba(255,255,255, .5)"></path><path d="M0 0 L50 50 L100 0 L0 0" fill="rgba(255,255,255, 1)"></path><path d="M48 48 L50 51 L52 48 L48 48" fill="rgba(255,255,255, 1)"></path> </svg></div></footer><script async src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script> <script>window.jQuery || document.write('<script src="https://womanonrails.com/assets/js/vendor/jquery-1.9.1.min.js"><\/script>')</script> <script src="https://womanonrails.com/assets/js/scripts.min.js"></script> <script type="text/javascript" src="https://womanonrails.com/assets/js/waypoints.min.js"></script> <script type="text/javascript" src="https://womanonrails.com/assets/js/script.js"></script> <script type='text/javascript'>$(document).ready(function(){$(".time").text(function(a,b){return Math.round(parseFloat(b))})});</script> <script type="text/javascript"> /* Slides */ $("a#slide").click(function(){ $("#sidebar,body,a#slide,#fade").addClass("slide") }); $("#fade,#header,#posts-container").click(function(){ $("#sidebar,body,a#slide,#fade").removeClass("slide") }); $("a#click-filter").click(function(){ $("#slide-filter").slideToggle("medium"); $("#slide-pages").slideOut("medium"); }); $("a#click-pages").click(function(){ $("#slide-pages").slideToggle("medium"); $("#slide-filter").slideOut("medium"); }); /* End-Slides */ </script> <script> $(document).ready(function() { $('.search-field').simpleJekyllSearch({ jsonFile : '/pl/search.json', searchResults : '.search-results', template : '<li><article><a href="{url}">{title} <span class="entry-date"><time datetime="{date}">{shortdate}</time></span></a></article></li>', noResults: '<p>Nothing found.</p>' }); }); (function( $, window, undefined ) { var bs = { close: $(".js-remove-sign"), searchform: $(".search-form"), canvas: $("body"), dothis: $('.dosearch') }; bs.dothis.on('click', function() { $('.search-wrapper').css({ display: "block" }); bs.searchform.toggleClass('active'); bs.searchform.find('input').focus(); bs.canvas.toggleClass('search-overlay'); }); bs.close.on('click', function() { $('.search-wrapper').removeAttr( 'style' ); bs.searchform.toggleClass('active'); bs.canvas.removeClass('search-overlay'); }); })( jQuery, window ); </script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-127731573-1"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-127731573-1'); </script></body></html>
